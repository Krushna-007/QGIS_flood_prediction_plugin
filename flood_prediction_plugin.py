# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FloodPredictionPlugin
                                 A QGIS plugin
 Flood risk prediction using machine learning models
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-08-26
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Krushna Parmar
        email                : krushna.parmar@example.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Modern QGIS Python API imports
import os.path
import traceback
import pickle

# PyQt imports
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, pyqtSignal, QVariant
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import (
    QAction, QFileDialog, QMessageBox, QTableWidgetItem, 
    QHeaderView, QTableWidget, QCheckBox
)

# QGIS Core imports - modern pattern
from qgis.core import (
    QgsProject, QgsRasterLayer, QgsVectorLayer, QgsPointXY, QgsGeometry, 
    QgsFeature, QgsField, QgsCoordinateReferenceSystem, QgsSymbol,
    QgsSingleSymbolRenderer, QgsMarkerSymbol, QgsCoordinateTransform,
    QgsRectangle, QgsRasterDataProvider, QgsRaster, QgsWkbTypes,
    QgsApplication, QgsSettings, QgsRasterIdentifyResult
)

# QGIS GUI imports
from qgis.gui import QgsMapToolEmitPoint
from qgis.utils import iface

# Plugin resources and dialogs
from .resources import *
from .flood_prediction_plugin_dialog import FloodPredictionPluginDialog
from .point_tool import PointTool

# Try to import optional libraries
try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False
    
try:
    import pandas as pd
    HAS_PANDAS = True
except ImportError:
    HAS_PANDAS = False


class FloodPredictionPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'FloodPredictionPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Flood Prediction Plugin')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Initialize plugin variables
        self.dlg = None
        self.point_tool = None
        self.selected_point = None
        self.model = None
        self.scaler = None
        self.feature_names = None
        self.model_info = None
        self.result_layer = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FloodPredictionPlugin', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/flood_prediction_plugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Flood Prediction Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Flood Prediction Plugin'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = FloodPredictionPluginDialog()
            
            # Connect signals
            self.dlg.pushButton_select_point.clicked.connect(self.select_point_tool)
            self.dlg.pushButton_load_model.clicked.connect(self.load_model)
            self.dlg.pushButton_predict.clicked.connect(self.make_prediction)
            self.dlg.pushButton_refresh_layers.clicked.connect(self.refresh_layers)
            self.dlg.pushButton_extract_data.clicked.connect(self.extract_data_from_layers)
            self.dlg.pushButton_clear_results.clicked.connect(self.clear_results)
            
            # Initialize the dialog
            self.refresh_layers()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pass

    def select_point_tool(self):
        """Activate point selection tool"""
        try:
            if not self.point_tool:
                self.point_tool = PointTool(self.iface.mapCanvas())
                self.point_tool.point_selected.connect(self.on_point_selected)
            
            self.iface.mapCanvas().setMapTool(self.point_tool)
            self.dlg.label_status.setText("Click on the map to select a point...")
            
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Failed to activate point selection tool: {str(e)}")

    def on_point_selected(self, point):
        """Handle point selection"""
        try:
            self.selected_point = point
            self.dlg.lineEdit_x_coord.setText(f"{point.x():.6f}")
            self.dlg.lineEdit_y_coord.setText(f"{point.y():.6f}")
            self.dlg.label_status.setText(f"Point selected: ({point.x():.6f}, {point.y():.6f})")
            
            # Create visualization point
            self.create_point_visualization(point)
            
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Failed to process selected point: {str(e)}")

    def create_point_visualization(self, point):
        """Create a visual representation of the selected point"""
        try:
            # Remove existing result layer
            if self.result_layer:
                QgsProject.instance().removeMapLayer(self.result_layer)
            
            # Create new point layer
            crs = self.iface.mapCanvas().mapSettings().destinationCrs().authid()
            self.result_layer = QgsVectorLayer(f'Point?crs={crs}', 'Selected Point', 'memory')
            
            provider = self.result_layer.dataProvider()
            provider.addAttributes([
                QgsField('x_coord', QVariant.Double),
                QgsField('y_coord', QVariant.Double),
                QgsField('prediction', QVariant.String),
                QgsField('probability', QVariant.Double)
            ])
            self.result_layer.updateFields()
            
            # Add point feature
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromPointXY(point))
            feature.setAttributes([point.x(), point.y(), 'Not predicted', 0.0])
            provider.addFeature(feature)
            
            # Style the point
            symbol = QgsMarkerSymbol.createSimple({
                'name': 'circle',
                'color': 'red',
                'size': '6',
                'outline_color': 'black',
                'outline_width': '1'
            })
            renderer = QgsSingleSymbolRenderer(symbol)
            self.result_layer.setRenderer(renderer)
            
            # Add to map
            QgsProject.instance().addMapLayer(self.result_layer)
            
        except Exception as e:
            QMessageBox.warning(self.dlg, "Warning", f"Could not create point visualization: {str(e)}")

    def refresh_layers(self):
        """Refresh the layer list with checkboxes"""
        try:
            print("üîÑ Refreshing layers...")
            
            # Clear existing checkboxes
            for checkbox in self.dlg.layer_checkboxes.values():
                checkbox.setParent(None)
                checkbox.deleteLater()
            self.dlg.layer_checkboxes.clear()
            
            # Clear the layout
            while self.dlg.scroll_layout.count():
                child = self.dlg.scroll_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            
            # Get all raster and vector layers
            layers = QgsProject.instance().mapLayers().values()
            print(f"Total layers in project: {len(list(layers))}")
            
            layer_count = 0
            layers = QgsProject.instance().mapLayers().values()  # Re-get the iterator
            
            for layer in layers:
                print(f"Processing layer: {layer.name()} - Type: {type(layer).__name__}")
                
                if isinstance(layer, (QgsRasterLayer, QgsVectorLayer)):
                    # Create checkbox for each layer
                    layer_display_name = f"{layer.name()} ({type(layer).__name__})"
                    # QCheckBox is now imported at the top - modern pattern
                    checkbox = QCheckBox(layer_display_name)
                    
                    # Store checkbox with the actual layer name as key
                    self.dlg.layer_checkboxes[layer.name()] = checkbox
                    self.dlg.scroll_layout.addWidget(checkbox)
                    layer_count += 1
                    
                    print(f"‚úÖ Added checkbox for: {layer.name()}")
            
            # Add stretch to push checkboxes to top
            self.dlg.scroll_layout.addStretch()
            
            print(f"üìä Total checkboxes created: {layer_count}")
            self.dlg.label_status.setText(f"Found {layer_count} layers - check boxes to select")
            
        except Exception as e:
            print(f"‚ùå Error refreshing layers: {e}")
            import traceback
            print(traceback.format_exc())
            QMessageBox.critical(self.dlg, "Error", f"Failed to refresh layers: {str(e)}")

    def load_model(self):
        """Load ML model (only requires .pkl file)"""
        try:
            # Browse for model file
            model_path, _ = QFileDialog.getOpenFileName(
                self.dlg, 
                "Select ML Model File", 
                "", 
                "Pickle files (*.pkl);;All files (*.*)"
            )
            
            if not model_path:
                return
            
            # Load model using pickle
            if model_path.endswith('.pkl'):
                with open(model_path, 'rb') as f:
                    self.model = pickle.load(f)
            else:
                QMessageBox.warning(self.dlg, "Warning", "Currently only .pkl models are supported")
                return
            
            # Reset optional components (not required)
            self.scaler = None
            self.feature_names = None
            self.model_info = None
            
            # Update UI
            self.dlg.lineEdit_model_path.setText(model_path)
            self.dlg.label_model_features.setText("Model loaded - will use available layer data")
            self.dlg.label_model_info.setText("Model ready for predictions")
            
            self.dlg.label_status.setText("Model loaded successfully! No additional files required.")
            
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Failed to load model: {str(e)}\n{traceback.format_exc()}")

    def extract_data_from_layers(self):
        """Extract data from selected layers at the selected point"""
        try:
            print("üöÄ Starting data extraction...")
            
            if not self.selected_point:
                QMessageBox.warning(self.dlg, "Warning", "Please select a point first")
                return
            
            print(f"üìç Selected point: {self.selected_point.x()}, {self.selected_point.y()}")
            print(f"üìã Available layer checkboxes: {len(self.dlg.layer_checkboxes)}")
            
            # Get checked layers
            selected_layers = []
            for layer_name, checkbox in self.dlg.layer_checkboxes.items():
                print(f"Checkbox '{layer_name}': {checkbox.isChecked()}")
                if checkbox.isChecked():
                    selected_layers.append(layer_name)
            
            print(f"‚úÖ Selected layers: {selected_layers}")
            
            if not selected_layers:
                QMessageBox.warning(self.dlg, "Warning", "Please check at least one layer")
                return
            
            # Clear previous data
            self.dlg.tableWidget_data.setRowCount(0)
            
            extracted_data = {}
            row = 0
            successful_extractions = 0
            
            for layer_name in selected_layers:
                print(f"\nüîç Processing layer: {layer_name}")
                layer = self.get_layer_by_name(layer_name)
                
                if not layer:
                    print(f"‚ùå Layer not found in project: {layer_name}")
                    continue
                
                print(f"‚úÖ Layer found: {layer.name()} - Type: {type(layer).__name__}")
                print(f"   Layer is valid: {layer.isValid()}")
                print(f"   Layer extent: {layer.extent()}")
                
                if isinstance(layer, QgsRasterLayer):
                    print(f"üìä Processing raster layer: {layer_name}")
                    # Extract raster values using V2 official pattern - no boolean iteration possible
                    values = self.extract_raster_values(layer, self.selected_point)
                    print(f"üéØ Raster values extracted: {values}")
                    
                    if values:
                        successful_extractions += 1
                        for band, value in values.items():
                            original_attr = f"{layer_name}_band_{band}" if len(values) > 1 else layer_name
                            # Create a clean feature name suggestion with smart mapping
                            feature_name = self.suggest_feature_name(layer_name)
                            if len(values) > 1:
                                feature_name += f"_band_{band}"
                            
                            extracted_data[feature_name] = value
                            
                            # Add to table
                            self.dlg.tableWidget_data.insertRow(row)
                            self.dlg.tableWidget_data.setItem(row, 0, QTableWidgetItem(layer_name))
                            self.dlg.tableWidget_data.setItem(row, 1, QTableWidgetItem(original_attr))
                            # Feature name column - editable
                            feature_item = QTableWidgetItem(feature_name)
                            self.dlg.tableWidget_data.setItem(row, 2, feature_item)
                            # Value column - read only
                            value_item = QTableWidgetItem(f"{value:.6f}")
                            value_item.setFlags(value_item.flags() & ~Qt.ItemIsEditable)
                            self.dlg.tableWidget_data.setItem(row, 3, value_item)
                            row += 1
                            print(f"‚úÖ Added to table: {feature_name} = {value}")
                    else:
                        print(f"‚ùå No values extracted from raster layer: {layer_name}")
                
                elif isinstance(layer, QgsVectorLayer):
                    print(f"üó∫Ô∏è Processing vector layer: {layer_name}")
                    # Extract vector attributes (from intersecting features)
                    values = self.extract_vector_values(layer, self.selected_point)
                    print(f"üéØ Vector values extracted: {values}")
                    
                    if values:
                        successful_extractions += 1
                        for attr_name, value in values.items():
                            original_attr = f"{layer_name}_{attr_name}"
                            # Create a clean feature name suggestion with smart mapping
                            feature_name = self.suggest_feature_name(f"{layer_name}_{attr_name}")
                            
                            extracted_data[feature_name] = value
                            
                            # Add to table
                            self.dlg.tableWidget_data.insertRow(row)
                            self.dlg.tableWidget_data.setItem(row, 0, QTableWidgetItem(layer_name))
                            self.dlg.tableWidget_data.setItem(row, 1, QTableWidgetItem(original_attr))
                            # Feature name column - editable
                            feature_item = QTableWidgetItem(feature_name)
                            self.dlg.tableWidget_data.setItem(row, 2, feature_item)
                            # Value column - read only
                            value_item = QTableWidgetItem(str(value))
                            value_item.setFlags(value_item.flags() & ~Qt.ItemIsEditable)
                            self.dlg.tableWidget_data.setItem(row, 3, value_item)
                            row += 1
                            print(f"‚úÖ Added to table: {feature_name} = {value}")
                    else:
                        print(f"‚ùå No values extracted from vector layer: {layer_name}")
            
            # Resize table columns
            self.dlg.tableWidget_data.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            
            # Store extracted data
            self.extracted_data = extracted_data
            
            print(f"\nüìä Final Results:")
            print(f"   - Selected layers: {len(selected_layers)}")
            print(f"   - Successful extractions: {successful_extractions}")
            print(f"   - Total attributes extracted: {len(extracted_data)}")
            print(f"   - Extracted data: {extracted_data}")
            
            if len(extracted_data) > 0:
                self.dlg.label_status.setText(f"‚úÖ Extracted {len(extracted_data)} attributes from {successful_extractions}/{len(selected_layers)} layers")
            else:
                self.dlg.label_status.setText(f"‚ùå No data extracted from {len(selected_layers)} layers - check point location and layer extents")
            
        except Exception as e:
            print(f"‚ùå Error in extract_data_from_layers: {e}")
            import traceback
            full_trace = traceback.format_exc()
            print(f"üìã Full traceback:\n{full_trace}")
            QMessageBox.critical(self.dlg, "Error", f"Failed to extract data: {str(e)}\n\nFull traceback:\n{full_trace}")

    def get_layer_by_name(self, name):
        """Get layer by name"""
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.name() == name:
                return layer
        return None
    
    def suggest_feature_name(self, original_name):
        """Suggest a clean feature name based on common flood modeling terms"""
        # Convert to lowercase and replace spaces/special chars with underscores
        clean_name = original_name.lower().replace(' ', '_').replace('-', '_')
        
        # Common mappings for flood modeling features
        mappings = {
            'elevation': 'dem',
            'dem': 'dem',
            'digital_elevation': 'dem',
            'digital_elevation_model': 'dem',
            'height': 'dem',
            'altitude': 'dem',
            'slope': 'slope',
            'gradient': 'slope',
            'aspect': 'aspect',
            'twi': 'twi',
            'topographic_wetness_index': 'twi',
            'wetness_index': 'twi',
            'spi': 'spi',
            'stream_power_index': 'spi',
            'flow_accumulation': 'flow_accumulation',
            'flow_acc': 'flow_accumulation',
            'accumulation': 'flow_accumulation',
            'ndvi': 'ndvi',
            'vegetation': 'ndvi',
            'normalized_difference_vegetation': 'ndvi',
            'curvature': 'curvature',
            'roughness': 'roughness',
            'distance': 'distance',
            'filled': 'dem_filled',
            'direction': 'dem_filled_direction'
        }
        
        # Check for direct matches first
        for key, value in mappings.items():
            if key in clean_name:
                return value
        
        # Return cleaned original name if no mapping found
        return clean_name

    def extract_raster_values(self, layer, point):
        """
        Extract values from raster layer using OFFICIAL QGIS documentation pattern
        Based on V2 success: https://api.qgis.org/api/classQgsRasterDataProvider.html
        Pattern: value, success = provider.sample(point, band)
        """
        try:
            print(f"\nüéØ V2 OFFICIAL PATTERN: {layer.name()}")
            
            # Validate inputs
            if not layer or not isinstance(layer, QgsRasterLayer) or not layer.isValid():
                print(f"‚ùå Invalid raster layer")
                return {}
            
            provider = layer.dataProvider()
            if not provider or not provider.isValid():
                print(f"‚ùå Invalid raster provider")
                return {}
            
            print(f"‚úÖ Valid layer: {layer.name()}")
            print(f"‚úÖ Provider: {provider.name()}")
            print(f"‚úÖ Bands: {layer.bandCount()}")
            
            # Handle coordinate transformation
            canvas_crs = self.iface.mapCanvas().mapSettings().destinationCrs()
            layer_crs = layer.crs()
            
            if canvas_crs.authid() != layer_crs.authid():
                transform = QgsCoordinateTransform(canvas_crs, layer_crs, QgsProject.instance())
                try:
                    transformed_point = transform.transform(point)
                    print(f"üìç Transformed: {point.x():.6f},{point.y():.6f} ‚Üí {transformed_point.x():.6f},{transformed_point.y():.6f}")
                except Exception as transform_error:
                    print(f"‚ùå Transform failed: {transform_error}")
                    return {}
            else:
                transformed_point = point
                print(f"üìç No transform needed: {transformed_point.x():.6f},{transformed_point.y():.6f}")
            
            # OFFICIAL DOCUMENTATION PATTERN: Use sample() method
            # Returns tuple (value, success) as documented
            band_number = 1  # Sample from band 1 (1-based index)
            
            print(f"üîß Sampling at point: {transformed_point.x()}, {transformed_point.y()}")
            
            # This is the EXACT pattern from official QGIS documentation - PROVEN WORKING IN V2
            value, success = provider.sample(transformed_point, band_number)
            
            print(f"üìä Sample result: value={value}, success={success}")
            
            if success:
                # Check for NaN values as recommended in documentation
                import math
                if not math.isnan(value):
                    extracted_values = {1: float(value)}
                    is_normalized = 0.0 <= value <= 1.0
                    print(f"‚úÖ EXTRACTED: {value} (normalized: {is_normalized})")
                    return extracted_values
                else:
                    print(f"‚ùå Sampled value is NaN")
                    return {}
            else:
                print(f"‚ùå Sampling failed - point outside extent or invalid band")
                return {}
                
        except Exception as e:
            print(f"‚ùå Exception in extract_raster_values: {str(e)}")
            import traceback
            traceback.print_exc()
            return {}

    def extract_vector_values(self, layer, point):
        """Extract values from vector layer features that intersect the point"""
        try:
            # Transform point to layer CRS if needed
            canvas_crs = self.iface.mapCanvas().mapSettings().destinationCrs()
            layer_crs = layer.crs()
            
            if canvas_crs != layer_crs:
                transform = QgsCoordinateTransform(canvas_crs, layer_crs, QgsProject.instance())
                transformed_point = transform.transform(point)
            else:
                transformed_point = point
            
            # Create small buffer around point for intersection
            buffer_size = 1.0  # Small buffer in map units
            geometry = QgsGeometry.fromPointXY(transformed_point).buffer(buffer_size, 5)
            
            # Find intersecting features
            features = layer.getFeatures()
            extracted_values = {}
            
            for feature in features:
                if feature.geometry() and feature.geometry().intersects(geometry):
                    # Get all attributes
                    attributes = feature.attributes()
                    field_names = [field.name() for field in layer.fields()]
                    
                    for i, attr_name in enumerate(field_names):
                        if i < len(attributes) and attributes[i] is not None:
                            try:
                                # Try to convert to float for numeric values
                                value = float(attributes[i])
                                extracted_values[attr_name] = value
                            except (ValueError, TypeError):
                                # Keep as string for non-numeric values
                                extracted_values[attr_name] = str(attributes[i])
                    
                    # Only take first intersecting feature
                    break
            
            return extracted_values
            
        except Exception as e:
            print(f"Error extracting vector values: {e}")
            return {}

    def make_prediction(self):
        """Make flood prediction using loaded model"""
        try:
            if not self.model:
                QMessageBox.warning(self.dlg, "Warning", "Please load a model first")
                return
            
            # Get data from the editable table instead of stored extracted_data
            if self.dlg.tableWidget_data.rowCount() == 0:
                QMessageBox.warning(self.dlg, "Warning", "Please extract data from layers first")
                return
            
            # Read feature names and values from the table
            features_dict = {}
            features = []
            feature_names = []
            
            for row in range(self.dlg.tableWidget_data.rowCount()):
                # Get the edited feature name (column 2) and value (column 3)
                feature_name_item = self.dlg.tableWidget_data.item(row, 2)
                value_item = self.dlg.tableWidget_data.item(row, 3)
                
                if feature_name_item and value_item:
                    feature_name = feature_name_item.text().strip()
                    value_text = value_item.text().strip()
                    
                    # Convert value to numeric
                    try:
                        value = float(value_text)
                        features_dict[feature_name] = value
                        features.append(value)
                        feature_names.append(feature_name)
                    except (ValueError, TypeError):
                        # Use 0.0 for non-numeric values
                        features_dict[feature_name] = 0.0
                        features.append(0.0)
                        feature_names.append(feature_name)
            
            if not features:
                QMessageBox.warning(self.dlg, "Warning", "No valid numeric features found")
                return
            
            print(f"Using features: {features_dict}")
            
            # Convert to format expected by model
            if HAS_NUMPY:
                features_array = np.array(features).reshape(1, -1)
            else:
                # Use nested list format for sklearn models when numpy not available
                features_array = [features]
            
            # Note: No scaling applied since we're working with just the model file
            
            # Make prediction
            prediction_result = self.model.predict(features_array)
            prediction = prediction_result[0] if isinstance(prediction_result, (list, tuple)) else prediction_result
            
            # Get probability if available
            try:
                probabilities = self.model.predict_proba(features_array)
                if isinstance(probabilities, (list, tuple)) and len(probabilities) > 0:
                    probs = probabilities[0] if isinstance(probabilities[0], (list, tuple)) else probabilities
                    flood_probability = probs[1] if len(probs) > 1 else 0.5
                else:
                    flood_probability = 0.5
            except Exception as prob_e:
                print(f"Probability calculation failed: {prob_e}")
                flood_probability = 0.5
            
            # Update results
            prediction_text = "Flood Risk" if prediction == 1 else "No Flood Risk"
            self.dlg.label_prediction_result.setText(f"Prediction: {prediction_text}")
            self.dlg.label_probability.setText(f"Flood Probability: {flood_probability:.4f}")
            
            # Update visualization
            if self.result_layer:
                feature = next(self.result_layer.getFeatures())
                self.result_layer.dataProvider().changeAttributeValues({
                    feature.id(): {2: prediction_text, 3: flood_probability}
                })
                
                # Update symbol color based on prediction
                color = 'red' if prediction == 1 else 'green'
                symbol = QgsMarkerSymbol.createSimple({
                    'name': 'circle',
                    'color': color,
                    'size': str(6 + flood_probability * 4),  # Size based on probability
                    'outline_color': 'black',
                    'outline_width': '1'
                })
                renderer = QgsSingleSymbolRenderer(symbol)
                self.result_layer.setRenderer(renderer)
                self.result_layer.triggerRepaint()
            
            # Show detailed info about features used
            features_summary = f"Used {len(features)} features: {', '.join(feature_names[:3])}{'...' if len(feature_names) > 3 else ''}"
            self.dlg.label_status.setText(f"Prediction: {prediction_text} | Probability: {flood_probability:.4f}")
            
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Failed to make prediction: {str(e)}\n{traceback.format_exc()}")

    def clear_results(self):
        """Clear all results and selections"""
        try:
            # Clear point selection
            self.selected_point = None
            self.dlg.lineEdit_x_coord.clear()
            self.dlg.lineEdit_y_coord.clear()
            
            # Clear data table
            self.dlg.tableWidget_data.setRowCount(0)
            
            # Clear results
            self.dlg.label_prediction_result.setText("Prediction: Not available")
            self.dlg.label_probability.setText("Probability: Not available")
            
            # Remove visualization layer
            if self.result_layer:
                QgsProject.instance().removeMapLayer(self.result_layer)
                self.result_layer = None
            
            # Clear extracted data
            if hasattr(self, 'extracted_data'):
                del self.extracted_data
            
            self.dlg.label_status.setText("Results cleared")
            
        except Exception as e:
            QMessageBox.critical(self.dlg, "Error", f"Failed to clear results: {str(e)}")
